module serial(A, B, reset, clock, sum);
input [7:0] A, B;
input reset, clock;
output [7:0] sum;
reg [3:0] count;
reg s, y, Y;
wire [7:0] qa, qb, sum;
wire run;
parameter G = 0 , H = 1;
shiftreg A1(A, reset, 1'b1, 1'b0, clock, qa);
shiftreg B1 (B, reset, 1'b1, 1'b0, clock, qb);
shiftreg C1 (8'b0, reset, run, s, clock, sum);
always@(qa, qb, y) // full adder fsm
begin
case (y)
G: begin
s=qa[0]^qb[0]; 
if(qa[0]& qb[0] ) 
Y = H ;
else Y = G; 
end
H: begin
s=qa[0]~^qb[0]; 
if(~qa[0]&~qb[0] ) 
Y = H ;
else 
Y = G;
end
default: Y = G;
endcase
end
always@(posedge clock)
if (reset)
y = G;
else
y = Y;
always @(posedge clock)
if (reset)
count = 8;
else if (run) count = count-1;
assign run =| count;
endmodule
module shiftreg (R, L, E, W, clock, q);
parameter n = 8;
input [n - 1:0] R;
input L, E, W, clock;
output [n - 1:0] q;
reg [n - 1:0] q;
integer k;
always @(posedge clock)
if (L)
q <= R;
else if (E)
begin
for (k= n - 1 ;k > 0 ; k = k - 1 )
q[k - 1] <= q [k];
q[n - 1] <= W;
end
endmodule


module serialtb;
reg [7:0] A,B;
reg reset;
reg clock;
wire [7:0] sum;

serial dut(A,B,reset,clock,sum);

initial
begin
reset=1;
clock=0;
A=8'hA0;
B=8'h1F;
#10;
reset=0;
end
always
#5 clock=~clock;
endmodule


create_clock -name clk -period 10 -waveform {0 5} [get_ports clk]
set_input_delay -max 1.0 [get_ports reset] -clock [get_clocks clk] 
set_output_delay -max 1.0 [get_ports count] -clock [get_clocks clk]
